<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ap010gi2e</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ap010gi2e.github.io/"/>
  <updated>2017-12-10T12:11:12.778Z</updated>
  <id>http://ap010gi2e.github.io/</id>
  
  <author>
    <name>ap010gi2e</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>同步、异步、阻塞、非阻塞</title>
    <link href="http://ap010gi2e.github.io/2017/12/10/cjb0qdf9400006zs6v0l4ab5c/"/>
    <id>http://ap010gi2e.github.io/2017/12/10/cjb0qdf9400006zs6v0l4ab5c/</id>
    <published>2017-12-10T09:20:42.000Z</published>
    <updated>2017-12-10T12:11:12.778Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h1><ul><li>阻塞是指在调用结果返回之前，当前的线程会被挂起。函数只有得到返回结果的时候才会返回。</li></ul><h1 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h1><ul><li>非阻塞和阻塞是相对的概念，指在没有得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</li></ul><h1 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h1><ul><li>所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。</li></ul><h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><ul><li>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</li></ul><h1 id="对象的阻塞模式和阻塞函数调用"><a href="#对象的阻塞模式和阻塞函数调用" class="headerlink" title="对象的阻塞模式和阻塞函数调用"></a>对象的阻塞模式和阻塞函数调用</h1><ul><li>对象是否处于阻塞模式和函数是不是阻塞调用有很强的相关性，但是并不是一一对应的。阻塞对象上可以有非阻塞的调用方式，我们可以通过一定的API去轮询状态，在适当的时候调用阻塞函数，就可以避免阻塞。而对于非阻塞对象，调用特殊的函数也可以进入阻塞调用。函数select就是这样的一个例子。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;阻塞&quot;&gt;&lt;a href=&quot;#阻塞&quot; class=&quot;headerlink&quot; title=&quot;阻塞&quot;&gt;&lt;/a&gt;阻塞&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;阻塞是指在调用结果返回之前，当前的线程会被挂起。函数只有得到返回结果的时候才会返回。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;非阻
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>进程和线程</title>
    <link href="http://ap010gi2e.github.io/2017/12/10/cjb0qdf9900026zs6qc2c0ihv/"/>
    <id>http://ap010gi2e.github.io/2017/12/10/cjb0qdf9900026zs6qc2c0ihv/</id>
    <published>2017-12-10T06:49:24.000Z</published>
    <updated>2017-12-10T06:52:14.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><ul><li>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。</li><li>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.</li></ul><h1 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h1><ul><li>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.</li><li>相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。</li></ul><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p><ul><li>简而言之,一个程序至少有一个进程,一个进程至少有一个线程.</li><li>线程的划分尺度小于进程，使得多线程程序的并发性高。</li><li>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</li><li>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li><li>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</li></ul><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><ul><li>线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。&lt;/li&gt;
&lt;li&gt;线
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>进、线程间通信</title>
    <link href="http://ap010gi2e.github.io/2017/12/10/cjb0qdf9700016zs6rg37ycyq/"/>
    <id>http://ap010gi2e.github.io/2017/12/10/cjb0qdf9700016zs6rg37ycyq/</id>
    <published>2017-12-10T05:12:58.000Z</published>
    <updated>2017-12-10T05:48:34.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、进程间通信"><a href="#一、进程间通信" class="headerlink" title="一、进程间通信"></a>一、进程间通信</h1><ul><li>管道(pipe):一种半双工的通信方式。数据单向传输。只能在具有亲缘关系的进程间使用。</li><li>有名管道(namepipe):区别在于它允许非亲缘关系的进程间通信。</li><li>信号量(semaphore):是一种计数器，可以控制多个进程对共享资源的访问。常作为一种锁机制，用来防止多个进程同时访问共享资源。主要用作进程间以及同一进程内不同线程之间的同步手段。</li><li>信号(signal):比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li><li>消息队列(messagequeue):由消息的链表存放在内核中，并由消息队列标识符标识。克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等问题。</li><li>共享内存(shared memory):通过映射一段能被其他进程访问的内存。由一个进程创建，多个进程共享访问。是最快的IPC方式。常常与其他通信机制配合使用。如信号量等，来实现进程间的同步和通信。</li><li>套接字(socket):可用于不同之间的进程通信。</li></ul><h1 id="二、线程间通信"><a href="#二、线程间通信" class="headerlink" title="二、线程间通信"></a>二、线程间通信</h1><ul><li>锁机制<ul><li>互斥锁:一种同步机制，防止多个线程共同操作同一共享资源。</li><li>读写锁:允许多个线程同时读取共享数据，但是对于写操作则是互斥的。</li><li>条件变量:可以以原子的方式阻塞进程，直到某个特定条件为真时为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li></ul></li><li>信号量机制:包括无名线程信号量和命名线程信号量。</li><li>信号机制:类似进程间的信号处理。</li><li>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、进程间通信&quot;&gt;&lt;a href=&quot;#一、进程间通信&quot; class=&quot;headerlink&quot; title=&quot;一、进程间通信&quot;&gt;&lt;/a&gt;一、进程间通信&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;管道(pipe):一种半双工的通信方式。数据单向传输。只能在具有亲缘关系的进程间使用。&lt;
      
    
    </summary>
    
    
  </entry>
  
</feed>
